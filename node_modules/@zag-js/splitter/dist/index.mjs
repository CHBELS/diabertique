import { createAnatomy } from '@zag-js/anatomy';
import { getRelativePoint, raf, trackPointerMove, dataAttr, getEventStep, getEventKey } from '@zag-js/dom-query';
import { setRafTimeout, createSplitProps, ensure } from '@zag-js/utils';
import { createMachine } from '@zag-js/core';
import { createProps } from '@zag-js/types';

// src/splitter.anatomy.ts
var anatomy = createAnatomy("splitter").parts("root", "panel", "resizeTrigger");
var parts = anatomy.build();
var getRootId = (ctx) => ctx.ids?.root ?? `splitter:${ctx.id}`;
var getResizeTriggerId = (ctx, id) => ctx.ids?.resizeTrigger?.(id) ?? `splitter:${ctx.id}:splitter:${id}`;
var getPanelId = (ctx, id) => ctx.ids?.panel?.(id) ?? `splitter:${ctx.id}:panel:${id}`;
var getGlobalCursorId = (ctx) => `splitter:${ctx.id}:global-cursor`;
var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
var getResizeTriggerEl = (ctx, id) => ctx.getById(getResizeTriggerId(ctx, id));
var getCursor = (state, x) => {
  let cursor = x ? "col-resize" : "row-resize";
  if (state.isAtMin) cursor = x ? "e-resize" : "s-resize";
  if (state.isAtMax) cursor = x ? "w-resize" : "n-resize";
  return cursor;
};
var getPanelStyle = (panels, id) => {
  const flexGrow = panels.find((panel) => panel.id === id)?.size ?? "0";
  return { flexBasis: 0, flexGrow, flexShrink: 1, overflow: "hidden" };
};
var setupGlobalCursor = (ctx, state, x) => {
  const styleEl = ctx.getById(getGlobalCursorId(ctx));
  const textContent = `* { cursor: ${getCursor(state, x)} !important; }`;
  if (styleEl) {
    styleEl.textContent = textContent;
  } else {
    const style = ctx.getDoc().createElement("style");
    style.id = getGlobalCursorId(ctx);
    style.textContent = textContent;
    ctx.getDoc().head.appendChild(style);
  }
};
var removeGlobalCursor = (ctx) => {
  const styleEl = ctx.getById(getGlobalCursorId(ctx));
  styleEl?.remove();
};

// src/splitter.utils.ts
function validateSize(key, size) {
  if (Math.floor(size) > 100) {
    throw new Error(`Total ${key} of panels cannot be greater than 100`);
  }
}
function getNormalizedPanels(sizes) {
  let numOfPanelsWithoutSize = 0;
  let totalSize = 0;
  let totalMinSize = 0;
  const panels = sizes.map((panel) => {
    const minSize = panel.minSize ?? 0;
    const maxSize = panel.maxSize ?? 100;
    totalMinSize += minSize;
    if (panel.size == null) {
      numOfPanelsWithoutSize++;
    } else {
      totalSize += panel.size;
    }
    return {
      ...panel,
      minSize,
      maxSize
    };
  });
  validateSize("minSize", totalMinSize);
  validateSize("size", totalSize);
  let end = 0;
  let remainingSize = 0;
  const result = panels.map((panel) => {
    let start = end;
    if (panel.size != null) {
      end += panel.size;
      remainingSize = panel.size - panel.minSize;
      return {
        ...panel,
        start,
        end,
        remainingSize
      };
    }
    const size = (100 - totalSize) / numOfPanelsWithoutSize;
    end += size;
    remainingSize = size - panel.minSize;
    return { ...panel, size, start, end, remainingSize };
  });
  return result;
}
function getHandlePanels(panels, id) {
  const [beforeId, afterId] = id?.split(":") ?? [];
  if (!beforeId || !afterId) return;
  const beforeIndex = panels.findIndex((panel) => panel.id === beforeId);
  const afterIndex = panels.findIndex((panel) => panel.id === afterId);
  if (beforeIndex === -1 || afterIndex === -1) return;
  const before = panels[beforeIndex];
  const after = panels[afterIndex];
  return {
    before: {
      ...before,
      index: beforeIndex
    },
    after: {
      ...after,
      index: afterIndex
    }
  };
}
function getHandleBounds(panels, id) {
  const handlePanels = getHandlePanels(panels, id);
  if (!handlePanels) return;
  const { before, after } = handlePanels;
  return {
    min: Math.max(before.start + before.minSize, after.end - after.maxSize),
    max: Math.min(after.end - after.minSize, before.maxSize + before.start)
  };
}
function getPanelBounds(panels, id) {
  const bounds = getHandleBounds(panels, id);
  const handlePanels = getHandlePanels(panels, id);
  if (!bounds || !handlePanels) return;
  const { before, after } = handlePanels;
  const beforeMin = Math.abs(before.start - bounds.min);
  const afterMin = after.size + (before.size - beforeMin);
  const beforeMax = Math.abs(before.start - bounds.max);
  const afterMax = after.size - (beforeMax - before.size);
  return {
    before: {
      index: before.index,
      min: beforeMin,
      max: beforeMax,
      isAtMin: beforeMin === before.size,
      isAtMax: beforeMax === before.size,
      up(step) {
        return Math.min(before.size + step, beforeMax);
      },
      down(step) {
        return Math.max(before.size - step, beforeMin);
      }
    },
    after: {
      index: after.index,
      min: afterMin,
      max: afterMax,
      isAtMin: afterMin === after.size,
      isAtMax: afterMax === after.size,
      up(step) {
        return Math.min(after.size + step, afterMin);
      },
      down(step) {
        return Math.max(after.size - step, afterMax);
      }
    }
  };
}
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

// src/splitter.connect.ts
function connect(service, normalize) {
  const { state, send, prop, computed, context, scope } = service;
  const horizontal = computed("isHorizontal");
  const focused = state.hasTag("focus");
  const dragging = state.matches("dragging");
  const panels = computed("panels");
  const activeResizeId = context.get("activeResizeId");
  function getResizeTriggerState(props2) {
    const { id, disabled } = props2;
    const ids = id.split(":");
    const panelIds = ids.map((id2) => getPanelId(scope, id2));
    const panels2 = getHandleBounds(computed("panels"), id);
    return {
      disabled: !!disabled,
      focused: activeResizeId === id && focused,
      panelIds,
      min: panels2?.min,
      max: panels2?.max,
      value: 0
    };
  }
  return {
    focused,
    dragging,
    getResizeTriggerState,
    bounds: getHandleBounds(computed("panels"), activeResizeId),
    setToMinSize(id) {
      const panel = panels.find((panel2) => panel2.id === id);
      send({ type: "SIZE.SET", id, size: panel?.minSize, src: "setToMinSize" });
    },
    setToMaxSize(id) {
      const panel = panels.find((panel2) => panel2.id === id);
      send({ type: "SIZE.SET", id, size: panel?.maxSize, src: "setToMaxSize" });
    },
    setSize(id, size) {
      send({ type: "SIZE.SET", id, size });
    },
    setSizes(sizes) {
      send({ type: "SIZES.SET", sizes });
    },
    getSize(id) {
      const panel = panels.find((panel2) => panel2.id === id);
      ensure(panel, `Panel with id ${id} not found`);
      return panel.size;
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        "data-orientation": prop("orientation"),
        id: getRootId(scope),
        dir: prop("dir"),
        style: {
          display: "flex",
          flexDirection: horizontal ? "row" : "column",
          height: "100%",
          width: "100%",
          overflow: "hidden"
        }
      });
    },
    getPanelProps(props2) {
      const { id } = props2;
      return normalize.element({
        ...parts.panel.attrs,
        "data-orientation": prop("orientation"),
        dir: prop("dir"),
        id: getPanelId(scope, id),
        "data-ownedby": getRootId(scope),
        style: getPanelStyle(panels, id)
      });
    },
    getResizeTriggerProps(props2) {
      const { id, disabled, step = 1 } = props2;
      const triggerState = getResizeTriggerState(props2);
      return normalize.element({
        ...parts.resizeTrigger.attrs,
        dir: prop("dir"),
        id: getResizeTriggerId(scope, id),
        role: "separator",
        "data-ownedby": getRootId(scope),
        tabIndex: disabled ? void 0 : 0,
        "aria-valuenow": triggerState.value,
        "aria-valuemin": triggerState.min,
        "aria-valuemax": triggerState.max,
        "data-orientation": prop("orientation"),
        "aria-orientation": prop("orientation"),
        "aria-controls": triggerState.panelIds.join(" "),
        "data-focus": dataAttr(triggerState.focused),
        "data-disabled": dataAttr(disabled),
        style: {
          touchAction: "none",
          userSelect: "none",
          WebkitUserSelect: "none",
          flex: "0 0 auto",
          pointerEvents: dragging && !triggerState.focused ? "none" : void 0,
          cursor: horizontal ? "col-resize" : "row-resize",
          [horizontal ? "minHeight" : "minWidth"]: "0"
        },
        onPointerDown(event) {
          if (disabled) {
            event.preventDefault();
            return;
          }
          send({ type: "POINTER_DOWN", id });
          event.currentTarget.setPointerCapture(event.pointerId);
          event.preventDefault();
          event.stopPropagation();
        },
        onPointerUp(event) {
          if (disabled) return;
          if (event.currentTarget.hasPointerCapture(event.pointerId)) {
            event.currentTarget.releasePointerCapture(event.pointerId);
          }
        },
        onPointerOver() {
          if (disabled) return;
          send({ type: "POINTER_OVER", id });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "POINTER_LEAVE", id });
        },
        onBlur() {
          send({ type: "BLUR" });
        },
        onFocus() {
          send({ type: "FOCUS", id });
        },
        onDoubleClick() {
          if (disabled) return;
          send({ type: "DOUBLE_CLICK", id });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          const moveStep = getEventStep(event) * step;
          const keyMap = {
            Enter() {
              send({ type: "ENTER" });
            },
            ArrowUp() {
              send({ type: "ARROW_UP", step: moveStep });
            },
            ArrowDown() {
              send({ type: "ARROW_DOWN", step: moveStep });
            },
            ArrowLeft() {
              send({ type: "ARROW_LEFT", step: moveStep });
            },
            ArrowRight() {
              send({ type: "ARROW_RIGHT", step: moveStep });
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          const key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap[key];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}
var machine = createMachine({
  props({ props: props2 }) {
    return {
      orientation: "horizontal",
      defaultSize: [],
      ...props2
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      activeResizeId: bindable(() => ({
        defaultValue: null
      })),
      size: bindable(() => ({
        defaultValue: prop("defaultSize"),
        value: prop("size"),
        hash(a) {
          return a.map((panel) => `${panel.id}:${panel.size}`).join(",");
        },
        onChange(value) {
          const context = getContext();
          prop("onSizeChange")?.({
            size: value,
            activeHandleId: context.get("activeResizeId")
          });
        }
      })),
      activeResizeState: bindable(() => ({
        defaultValue: { isAtMin: false, isAtMax: false }
      }))
    };
  },
  refs({ context }) {
    return {
      previousPanels: getNormalizedPanels(context.get("size"))
    };
  },
  watch({ track, action, context }) {
    track([() => context.hash("size")], () => {
      action(["setActiveResizeState"]);
    });
  },
  computed: {
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal",
    panels: ({ context }) => getNormalizedPanels(context.get("size"))
  },
  on: {
    "SIZE.SET": {
      actions: ["setPanelSize"]
    },
    "SIZES.SET": {
      actions: ["setPanelSizes"]
    }
  },
  states: {
    idle: {
      entry: ["clearActiveHandleId"],
      on: {
        POINTER_OVER: {
          target: "hover:temp",
          actions: ["setActiveHandleId"]
        },
        FOCUS: {
          target: "focused",
          actions: ["setActiveHandleId"]
        },
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setActiveHandleId"]
        },
        DOUBLE_CLICK: {
          actions: ["resetStartPanel", "setPreviousPanels"]
        }
      }
    },
    "hover:temp": {
      effects: ["waitForHoverDelay"],
      on: {
        HOVER_DELAY: {
          target: "hover"
        },
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setActiveHandleId"]
        },
        POINTER_LEAVE: {
          target: "idle"
        }
      }
    },
    hover: {
      tags: ["focus"],
      on: {
        POINTER_DOWN: {
          target: "dragging"
        },
        POINTER_LEAVE: {
          target: "idle"
        }
      }
    },
    focused: {
      tags: ["focus"],
      on: {
        BLUR: {
          target: "idle"
        },
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setActiveHandleId"]
        },
        ARROW_LEFT: {
          guard: "isHorizontal",
          actions: ["shrinkStartPanel", "setPreviousPanels"]
        },
        ARROW_RIGHT: {
          guard: "isHorizontal",
          actions: ["expandStartPanel", "setPreviousPanels"]
        },
        ARROW_UP: {
          guard: "isVertical",
          actions: ["shrinkStartPanel", "setPreviousPanels"]
        },
        ARROW_DOWN: {
          guard: "isVertical",
          actions: ["expandStartPanel", "setPreviousPanels"]
        },
        ENTER: [
          {
            guard: "isStartPanelAtMax",
            actions: ["setStartPanelToMin", "setPreviousPanels"]
          },
          { actions: ["setStartPanelToMax", "setPreviousPanels"] }
        ],
        HOME: {
          actions: ["setStartPanelToMin", "setPreviousPanels"]
        },
        END: {
          actions: ["setStartPanelToMax", "setPreviousPanels"]
        }
      }
    },
    dragging: {
      tags: ["focus"],
      entry: ["focusResizeHandle"],
      effects: ["trackPointerMove"],
      on: {
        POINTER_MOVE: {
          actions: ["setPointerValue", "setGlobalCursor", "invokeOnResize"]
        },
        POINTER_UP: {
          target: "focused",
          actions: ["setPreviousPanels", "clearGlobalCursor", "blurResizeHandle", "invokeOnResizeEnd"]
        }
      }
    }
  },
  implementations: {
    effects: {
      waitForHoverDelay: ({ send }) => {
        return setRafTimeout(() => {
          send({ type: "HOVER_DELAY" });
        }, 250);
      },
      trackPointerMove: ({ scope, send }) => {
        const doc = scope.getDoc();
        return trackPointerMove(doc, {
          onPointerMove(info) {
            send({ type: "POINTER_MOVE", point: info.point });
          },
          onPointerUp() {
            send({ type: "POINTER_UP" });
          }
        });
      }
    },
    guards: {
      isStartPanelAtMin: ({ context }) => context.get("activeResizeState").isAtMin,
      isStartPanelAtMax: ({ context }) => context.get("activeResizeState").isAtMax,
      isHorizontal: ({ prop }) => prop("orientation") === "horizontal",
      isVertical: ({ prop }) => prop("orientation") !== "horizontal"
    },
    actions: {
      setGlobalCursor({ context, scope, computed }) {
        const activeState = context.get("activeResizeState");
        const isHorizontal = computed("isHorizontal");
        setupGlobalCursor(scope, activeState, isHorizontal);
      },
      clearGlobalCursor({ scope }) {
        removeGlobalCursor(scope);
      },
      invokeOnResize({ context, prop }) {
        prop("onSizeChange")?.({
          size: Array.from(context.get("size")),
          activeHandleId: context.get("activeResizeId")
        });
      },
      invokeOnResizeEnd({ context, prop }) {
        prop("onSizeChangeEnd")?.({
          size: Array.from(context.get("size")),
          activeHandleId: context.get("activeResizeId")
        });
      },
      setActiveHandleId({ context, event }) {
        context.set("activeResizeId", event.id);
      },
      clearActiveHandleId({ context }) {
        context.set("activeResizeId", null);
      },
      setPanelSize({ context, event }) {
        const { id, size } = event;
        context.set(
          "size",
          (prev) => prev.map((panel) => {
            const panelSize = clamp(size, panel.minSize ?? 0, panel.maxSize ?? 100);
            return panel.id === id ? { ...panel, size: panelSize } : panel;
          })
        );
      },
      setPanelSizes({ context, event }) {
        context.set("size", event.sizes);
      },
      setStartPanelToMin({ context, computed }) {
        const bounds = getPanelBounds(computed("panels"), context.get("activeResizeId"));
        if (!bounds) return;
        const { before, after } = bounds;
        context.set("size", (prev) => {
          const next = prev.slice();
          next[before.index].size = before.min;
          next[after.index].size = after.min;
          return next;
        });
      },
      setStartPanelToMax({ context, computed }) {
        const bounds = getPanelBounds(computed("panels"), context.get("activeResizeId"));
        if (!bounds) return;
        const { before, after } = bounds;
        context.set("size", (prev) => {
          const next = prev.slice();
          next[before.index].size = before.max;
          next[after.index].size = after.max;
          return next;
        });
      },
      expandStartPanel({ context, event, computed }) {
        const bounds = getPanelBounds(computed("panels"), context.get("activeResizeId"));
        if (!bounds) return;
        const { before, after } = bounds;
        context.set("size", (prev) => {
          const next = prev.slice();
          next[before.index].size = before.up(event.step);
          next[after.index].size = after.down(event.step);
          return next;
        });
      },
      shrinkStartPanel({ context, event, computed }) {
        const bounds = getPanelBounds(computed("panels"), context.get("activeResizeId"));
        if (!bounds) return;
        const { before, after } = bounds;
        context.set("size", (prev) => {
          const next = prev.slice();
          next[before.index].size = before.down(event.step);
          next[after.index].size = after.up(event.step);
          return next;
        });
      },
      resetStartPanel({ context, computed }) {
        const bounds = getPanelBounds(computed("panels"), context.get("activeResizeId"));
        if (!bounds) return;
        const { before, after } = bounds;
        const initialSize = context.initial("size");
        context.set("size", (prev) => {
          const next = prev.slice();
          next[before.index].size = initialSize[before.index].size;
          next[after.index].size = initialSize[after.index].size;
          return next;
        });
      },
      focusResizeHandle({ scope, context }) {
        raf(() => {
          const activeId = context.get("activeResizeId");
          if (!activeId) return;
          getResizeTriggerEl(scope, activeId)?.focus({ preventScroll: true });
        });
      },
      blurResizeHandle({ scope, context }) {
        raf(() => {
          const activeId = context.get("activeResizeId");
          if (!activeId) return;
          getResizeTriggerEl(scope, activeId)?.blur();
        });
      },
      setPreviousPanels({ refs, computed }) {
        refs.set("previousPanels", computed("panels").slice());
      },
      setActiveResizeState({ context, computed }) {
        const panels = getPanelBounds(computed("panels"), context.get("activeResizeId"));
        if (!panels) return;
        const { before } = panels;
        context.set("activeResizeState", {
          isAtMin: before.isAtMin,
          isAtMax: before.isAtMax
        });
      },
      setPointerValue({ context, event, prop, scope, computed }) {
        const panels = getHandlePanels(computed("panels"), context.get("activeResizeId"));
        const bounds = getHandleBounds(computed("panels"), context.get("activeResizeId"));
        if (!panels || !bounds) return;
        const rootEl = getRootEl(scope);
        if (!rootEl) return;
        const relativePoint = getRelativePoint(event.point, rootEl);
        const percentValue = relativePoint.getPercentValue({
          dir: prop("dir"),
          orientation: prop("orientation")
        });
        let pointValue = percentValue * 100;
        context.set("activeResizeState", {
          isAtMin: pointValue < bounds.min,
          isAtMax: pointValue > bounds.max
        });
        pointValue = clamp(pointValue, bounds.min, bounds.max);
        const { before, after } = panels;
        const offset = pointValue - before.end;
        context.set("size", (prev) => {
          const next = prev.slice();
          next[before.index].size = before.size + offset;
          next[after.index].size = after.size - offset;
          return next;
        });
      }
    }
  }
});
var props = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onSizeChange",
  "onSizeChangeEnd",
  "orientation",
  "size",
  "defaultSize"
]);
var splitProps = createSplitProps(props);
var panelProps = createProps()(["id", "snapSize"]);
var splitPanelProps = createSplitProps(panelProps);
var resizeTriggerProps = createProps()(["disabled", "id", "step"]);
var splitResizeTriggerProps = createSplitProps(resizeTriggerProps);

export { anatomy, connect, machine, panelProps, props, resizeTriggerProps, splitPanelProps, splitProps, splitResizeTriggerProps };
